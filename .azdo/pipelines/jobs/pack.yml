parameters:
- name: PackageArtifactName
- name: MajorVersion
- name: MinorVersion
- name: PatchVersion
- name: RevisionVersion

steps:
  - template: ./version.yml
    parameters:
      MajorVersion: $(MajorVersion)
      MinorVersion: $(MinorVersion)
      PatchVersion: $(PatchVersion)
      RevisionVersion: $(RevisionVersion)

  # Script is used here so we can pass custom parameters to dotnet pack
  - task: Bash@3
    displayName: Pack and Publish ${{ parameters.Version }}
    inputs:
      targetType: 'inline'
      script: |
        find . -type f \( -iname "*Microsoft.AzureHealth.DataServices.*.csproj" ! -iname "*Test*" ! -iname "*Sample*" \) -print0 | while read -d $'\0' file
        do
            echo "Packing $file with version $VERSION / $ASS_VERSION / $FILE_VERSION"
            dotnet pack "$file" --output "$PACKAGE_OUTPUT" /p:Configuration=Release /p:Version="$VERSION" /p:AssemblyVersion="$ASS_VERSION" /p:FileVersion="$FILE_VERSION" /p:PackageReleaseNotes="$NOTES"
        done
    env:
      VERSION: $(Version)
      FILE_VERSION: $(FileVersion)
      ASS_VERSION: ${{ parameters.MajorVersion }}.0.0.0
      PACKAGE_OUTPUT: $[ format('$(Build.ArtifactStagingDirectory)/{0}/{1}', parameters.PackageArtifactName, variables.Version) ]
      NOTES: $[ format('The change log for this version is made available at https://github.com/microsoft/azure-health-data-services-toolkit/releases/tag/release%2F{0}', variables.Version) ]

  - task: PublishPipelineArtifact@1
    displayName: Publish packages
    inputs:
      targetPath: $[ format('$(Build.ArtifactStagingDirectory)/{0}/{1}', parameters.PackageArtifactName, variables.Version) ]
      artifactName: ${{ parameters.PackageArtifactName }}
      artifactType: 'pipeline'
